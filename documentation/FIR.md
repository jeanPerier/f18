<!-- Autogenerated by mlir-tblgen; don't manually edit -->
# Dialect 'fir' definition

[TOC]

## Operation definition

### fir.addc (fir::AddcOp)


#### Description:



#### Operands:

1. `lhs`: FIR complex type
1. `rhs`: FIR complex type

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: any type

### fir.addf (fir::AddfOp)


#### Description:



#### Operands:

1. `lhs`: any real
1. `rhs`: any real

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: any type

### fir.address_of (fir::AddrOfOp)
convert a symbol to an SSA value

#### Description:


Convert a symbol (a function or global reference) to an SSA-value to be
used in other Operations.

```mlir
  %p = fir.address_of(@symbol) : !fir.ref<f64>
```

#### Operands:


#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `symbol` | `SymbolRefAttr` | symbol reference attribute attribute |

#### Results:

1. `resTy`: reference type

### fir.allocmem (fir::AllocMemOp)
allocate storage on the heap for an object of a given type

#### Description:


Creates a heap memory reference suitable for storing a value of the
given type, T.  The heap refernce returned has type `!fir.heap<T>`.
The memory object is in an undefined state.  `allocmem` operations must
be paired with `freemem` operations to avoid memory leaks.

```mlir
  %0 = fir.allocmem !fir.array<10 x f32>
  fir.freemem %0 : !fir.heap<!fir.array<10 x f32>>
```

#### Operands:

1. `args`: any integer

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `in_type` | `TypeAttr` | any type attribute attribute |

#### Results:

1. &laquo;unnamed&raquo;: allocatable type

### fir.alloca (fir::AllocaOp)
allocate storage for a temporary on the stack given a type

#### Description:


This primitive operation is used to allocate an object on the stack.  A
reference to the object of type `!fir.ref<T>` is returned.  The returned
object has an undefined/uninitialized state.  The allocation can be given
an optional name.  The allocation may have a dynamic repetition count
for allocating a sequence of locations for the specified type.

```mlir
  %c = ... : i64
  %x = fir.alloca i32
  %y = fir.alloca !fir.array<8 x i64>
  %z = fir.alloca f32, %c

  %i = ... : i16
  %j = ... : i32
  %w = fir.alloca !fir.type<PT(len1:i16, len2:i32)> (%i, %j : i16, i32)
```

Note that in the case of `%z`, a contiguous block of memory is allocated
and its size is a runtime multiple of a 32-bit REAL value.

In the case of `%w`, the arguments `%i` and `%j` are LEN parameters
(`len1`, `len2`) to the type `PT`.

Finally, the operation is undefined if the ssa-value `%c` is negative.

#### Operands:

1. `args`: any integer

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `in_type` | `TypeAttr` | any type attribute attribute |

#### Results:

1. &laquo;unnamed&raquo;: reference type

### fir.box_addr (fir::BoxAddrOp)
return a memory reference to the boxed value

#### Description:


This operator is overloaded to work with values of type `box`,
`boxchar`, and `boxproc`.  The result for each of these
cases, respectively, is the address of the data, the address of the
`CHARACTER` data, and the address of the procedure.

```mlir
  %51 = fir.box_addr %box : (!fir.box<f64>) -> !fir.ref<f64>
  %52 = fir.box_addr %boxchar : (!fir.boxchar<1>) -> !fir.ref<!fir.char<1>>
  %53 = fir.box_addr %boxproc : (!fir.boxproc<!P>) -> !fir.ref<!P>
```

#### Operands:

1. `val`: box type

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: any reference

### fir.boxchar_len (fir::BoxCharLenOp)
return the LEN type parameter from a boxchar value

#### Description:


Extracts the LEN type parameter from a `boxchar` value.

```mlir
  %45 = ... : !boxchar<1>  // CHARACTER(20)
  %59 = fir.boxchar_len %45 : (!fir.boxchar<1>) -> i64  // len=20
```

#### Operands:

1. `val`: box character type

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: any integer

### fir.box_dims (fir::BoxDimsOp)
return the dynamic dimension information for the boxed value

#### Description:


Returns the triple of lower bound, extent, and stride for `dim` dimension
of `val`, which must have a `box` type.  The dimensions are enumerated from
left to right from 0 to rank-1. This operation has undefined behavior if
`dim` is out of bounds.

```mlir
  %c1   = constant 0 : i32
  %52:3 = fir.box_dims %40, %c1 : (!fir.box<!fir.array<*:f64>>, i32) -> (i32, i32, i32)
```

The above is a request to return the left most row (at index 0) triple from
the box. The triple will be the lower bound, upper bound, and stride.

#### Operands:

1. `val`: box type
1. `dim`: any integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: any integer
1. &laquo;unnamed&raquo;: any integer
1. &laquo;unnamed&raquo;: any integer

### fir.box_elesize (fir::BoxEleSizeOp)
return the size of an element of the boxed value

#### Description:


Returns the size of an element in an entity of `box` type.  This size may
not be known until runtime.

```mlir
  %53 = fir.box_elesize %40 : (!fir.box<f32>, i32) -> i32  // size=4
  %54 = fir.box_elesize %40 : (!fir.box<!fir.array<*:f32>>, i32) -> i32
```

In the above example, `%53` may box an array of REAL values while `%54`
must box an array of REAL values (with dynamic rank and extent).

#### Operands:

1. `val`: box type

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: any integer

### fir.box_isalloc (fir::BoxIsAllocOp)
is the boxed value an ALLOCATABLE?

#### Description:


Determine if the boxed value was from an ALLOCATABLE entity. This will
return true if the originating box value was from a `fir.embox` op
with a mem-ref value that had the type !fir.heap<T>.

```mlir
  %r = ... : !fir.heap<i64>
  %b = fir.embox %r : (!fir.heap<i64>) -> !fir.box<i64>
  %a = fir.box_isalloc %b : (!fir.box<i64>) -> i1  // true
```

The canonical descriptor implementation will carry a flag to record if the
variable is an `ALLOCATABLE`.

#### Operands:

1. `val`: box type

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: bool-like

### fir.box_isarray (fir::BoxIsArrayOp)
is the boxed value an array?

#### Description:


Determine if the boxed value has a positive (> 0) rank. This will return
true if the originating box value was from a fir.embox with a memory
reference value that had the type !fir.array<T> and/or a dims argument.

```mlir
  %r = ... : !fir.ref<i64>
  %d = fir.gendims(1, 100, 1) : (i32, i32, i32) -> !fir.dims<1>
  %b = fir.embox %r, %d : (!fir.ref<i64>, !fir.dims<1>) -> !fir.box<i64>
  %a = fir.box_isarray %b : (!fir.box<i64>) -> i1  // true
```

#### Operands:

1. `val`: box type

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: bool-like

### fir.box_isptr (fir::BoxIsPtrOp)
is the boxed value a POINTER?

#### Description:


Determine if the boxed value was from a POINTER entity.

```mlir
  %p = ... : !fir.ptr<i64>
  %b = fir.embox %p : (!fir.ptr<i64>) -> !fir.box<i64>
  %a = fir.box_isptr %b : (!fir.box<i64>) -> i1  // true
```

#### Operands:

1. `val`: box type

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: bool-like

### fir.boxproc_host (fir::BoxProcHostOp)
returns the host instance pointer (or null)

#### Description:


Extract the host context pointer from a boxproc value.

```mlir
  %8 = ... : !fir.boxproc<(!fir.ref<!fir.type<T>>) -> i32>
  %9 = fir.boxproc_host %8 : (!fir.boxproc<(!fir.ref<!fir.type<T>>) -> i32>) -> !fir.ref<tuple<i32, i32>>
```

In the example, the reference to the closure over the host procedure's
variables is returned. This allows an internal procedure to access the
host's variables. It is up to lowering to determine the contract between
the host and the internal procedure.

#### Operands:

1. `val`: box procedure type

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: reference type

### fir.box_rank (fir::BoxRankOp)
return the number of dimensions for the boxed value

#### Description:


Return the rank of a value of `box` type.  If the value is scalar, the
rank is 0.

```mlir
  %57 = fir.box_rank %40 : (!fir.box<!fir.array<*:f64>>) -> i32
  %58 = fir.box_rank %41 : (!fir.box<f64>) -> i32
```

The example `%57` shows how one would determine the rank of an array that
has deferred rank at runtime. This rank should be at least 1. In %58, the
descriptor may be either an array or a scalar, so the value is nonnegative.

#### Operands:

1. `val`: box type

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: any integer

### fir.box_tdesc (fir::BoxTypeDescOp)
return the type descriptor for the boxed value

#### Description:


Return the opaque type descriptor of a value of `box` type. A type
descriptor is an implementation defined value that fully describes a type
to the Fortran runtime.

```mlir
  %7 = fir.box_tdesc %41 : (!fir.box<f64>) -> !fir.tdesc<f64>
```

#### Operands:

1. `val`: box type

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: type desc type

### fir.call (fir::CallOp)
call a procedure

#### Description:


Call the specified function or function reference.

Provides a custom parser and pretty printer to allow a more readable syntax
in the FIR dialect, e.g. `fir.call @sub(%12)` or `fir.call %20(%22,%23)`.

```mlir
  %a = fir.call %funcref(%arg0) : (!fir.ref<f32>) -> f32
  %b = fir.call @function(%arg1, %arg2) : (!fir.ref<f32>, !fir.ref<f32>) -> f32
```

#### Operands:

1. `args`: any type

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `callee` | `SymbolRefAttr` | symbol reference attribute attribute |

#### Results:

1. &laquo;unnamed&raquo;: any type

### fir.cmpc (fir::CmpcOp)
complex floating-point comparison operator

#### Description:


A complex comparison to handle complex types found in FIR.

#### Operands:

1. `lhs`: FIR complex type
1. `rhs`: FIR complex type

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: any logical

### fir.cmpf (fir::CmpfOp)
floating-point comparison operator

#### Description:


Extends the standard floating-point comparison to handle the extended
floating-point types found in FIR.

#### Operands:

1. `lhs`: any real
1. `rhs`: any real

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: any logical

### fir.constc (fir::ConstcOp)
create a complex constant

#### Description:


A complex constant. Similar to the standard dialect complex type, but this
extension allows constants with APFloat values that are not supported in
the standard dialect.

#### Operands:


#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: FIR complex type

### fir.constf (fir::ConstfOp)
create a floating point constant

#### Description:


A floating-point constant. This operation is to augment MLIR to be able
to represent APFloat values that are not supported in the standard dialect.

#### Operands:


#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `constant` | `fir::RealAttr` | FIR real attr attribute |

#### Results:

1. `res`: FIR real type

### fir.convert (fir::ConvertOp)
encapsulates all Fortran scalar type conversions

#### Description:


Generalized type conversion. Convert the ssa value from type T to type U.
Not all pairs of types have conversions. When types T and U are the same
type, this instruction is a NOP and may be folded away.

```mlir
  %v = ... : i64
  %w = fir.convert %v : (i64) -> i32
```

The example truncates the value `%v` from an i64 to an i32.

#### Operands:

1. `value`: any type

#### Attributes:


#### Results:

1. `res`: FIR dialect type

### fir.coordinate_of (fir::CoordinateOp)
Finds the coordinate (location) of a value in memory

#### Description:


Compute the internal coordinate address starting from a boxed value or
unboxed memory reference. Returns a memory reference. When computing the
coordinate of an array element, the rank of the array must be known and
the number of indexing expressions must equal the rank of the array.

This operation will apply the access map from a boxed value implicitly.

Unlike LLVM's GEP instruction, one cannot stride over the outermost
reference; therefore, the leading 0 index must be omitted.

```mlir
  %i = ... : index
  %h = ... : !fir.heap<!fir.array<?:f32>>
  %p = fir.coordinate_of %h, %i : (!fir.heap<!fir.array<?:f32>>, index) -> !fir.ref<f32>
```

In the example, `%p` will be a pointer to the `%i`-th f32 value in the
array `%h`.

#### Operands:

1. `ref`: any reference or box
1. `coor`: coordinate type

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: reference type

### fir.dt_entry (fir::DTEntryOp)
map entry in a dispatch table

#### Description:


An entry in a dispatch table.  Allows a function symbol to be bound
to a specifier method identifier.  A dispatch operation uses the dynamic
type of a distinguished argument to determine an exact dispatch table
and uses the method identifier to select the type-bound procedure to
be called.

```mlir
  fir.dt_entry method_name, @uniquedProcedure
```

#### Operands:


#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `method` | `StringAttr` | string attribute attribute |
| `proc` | `SymbolRefAttr` | symbol reference attribute attribute |

#### Results:


### fir.dispatch (fir::DispatchOp)
call a type-bound procedure

#### Description:


Perform a dynamic dispatch on the method name via the dispatch table
associated with the first argument.  The attribute 'pass_arg_pos' can be
used to select a dispatch argument other than the first one.

```mlir
  %r = fir.dispatch methodA(%o) : (!fir.box<none>) -> i32
```

#### Operands:

1. `object`: box type
1. `args`: any type

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `method` | `StringAttr` | string attribute attribute |

#### Results:

1. &laquo;unnamed&raquo;: any type

### fir.dispatch_table (fir::DispatchTableOp)
Dispatch table definition

#### Description:


Define a dispatch table for a derived type with type-bound procedures.

A dispatch table is an untyped symbol that contains a list of associations
between method identifiers and corresponding `FuncOp` symbols.

The ordering of associations in the map is determined by the front-end.

```mlir
  fir.dispatch_table @_QDTMquuzTfoo {
    fir.dt_entry method1, @_QFNMquuzTfooPmethod1AfooR
    fir.dt_entry method2, @_QFNMquuzTfooPmethod2AfooII
  }
```

#### Operands:


#### Attributes:


#### Results:


### fir.divc (fir::DivcOp)


#### Description:



#### Operands:

1. `lhs`: FIR complex type
1. `rhs`: FIR complex type

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: any type

### fir.divf (fir::DivfOp)


#### Description:



#### Operands:

1. `lhs`: any real
1. `rhs`: any real

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: any type

### fir.emboxchar (fir::EmboxCharOp)
boxes a given CHARACTER reference and its LEN parameter

#### Description:


Create a boxed CHARACTER value. The CHARACTER type has the LEN type
parameter, the value of which may only be known at runtime.  Therefore,
a variable of type CHARACTER has both its data reference as well as a
LEN type parameter.

```fortran
  CHARACTER(LEN=10) :: var
```
```mlir
  %4 = ...         : !fir.ref<!fir.array<10 x !fir.char<1>>>
  %5 = constant 10 : i32
  %6 = fir.emboxchar %4, %5 : (!fir.ref<!fir.array<10 x !fir.char<1>>>, i32) -> !fir.boxchar<1>
```

In the above `%4` is a memory reference to a buffer of 10 CHARACTER units.
This buffer and its LEN value (10) are wrapped into a pair in `%6`.

#### Operands:

1. `memref`: any reference
1. `len`: any integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: box character type

### fir.embox (fir::EmboxOp)
boxes a given reference and (optional) dimension information

#### Description:


Create a boxed reference value. In Fortran, the implementation can require
extra information about an entity, such as its type, rank, etc.  This
auxilliary information is packaged and abstracted as a value with box type
by the calling routine. (In Fortran, these are called descriptors.)

```mlir
  %c1 = constant 1 : index
  %c10 = constant 10 : index
  %4 = fir.dims(%c1, %c10, %c1) : (index, index, index) -> !fir.dims<1>
  %5 = ... : !fir.ref<!fir.array<10 x i32>>
  %6 = fir.embox %5, %4 : (!fir.ref<!fir.array<10 x i32>>, !fir.dims<1>) -> !fir.box<!fir.array<10 x i32>>
```

The descriptor tuple may contain additional implementation-specific
information through the use of additional attributes.

#### Operands:

1. `memref`: any reference
1. `args`: embox argument type

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: box type

### fir.emboxproc (fir::EmboxProcOp)
boxes a given procedure and optional host context

#### Description:


Creates an abstract encapsulation of a PROCEDURE POINTER along with an
optional pointer to a host instance context. If the pointer is not to an
internal procedure or the internal procedure does not need a host context
then the form takes only the procedure's symbol.

```mlir
  %0 = fir.emboxproc @f : ((i32) -> i32) -> !fir.boxproc<(i32) -> i32>
```

An internal procedure requiring a host instance for correct execution uses
the second form. The closure of the host procedure's state is passed as a
reference to a tuple. It is the responsibility of the host to manage the
context's values accordingly, up to and including inhibiting register
promotion of local values.

```mlir
  %4 = ... : !fir.ref<tuple<i32, i32>>
  %5 = fir.emboxproc @g, %4 : ((i32) -> i32, !fir.ref<tuple<i32, i32>>) -> !fir.boxproc<(i32) -> i32>
```

#### Operands:

1. `host`: any reference

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `funcname` | `SymbolRefAttr` | symbol reference attribute attribute |

#### Results:

1. &laquo;unnamed&raquo;: box procedure type

### fir.extract_value (fir::ExtractValueOp)
Extract a value from an aggregate SSA-value

#### Description:


Extract a value from an entity with a type composed of tuples, arrays,
and/or derived types. Returns the value from entity with the type of the
specified component. Cannot be used on values of `!fir.box` type.

Note that the entity ssa-value must be of compile-time known size in order
to use this operation.

```mlir
  %f = fir.field_index field, !fir.type<X{field:i32}>
  %s = ... : !fir.type<X>
  %v = fir.extract_value %s, %f : (!fir.type<X>, !fir.field) -> i32
```

#### Operands:

1. `adt`: any composite
1. `coor`: coordinate type

#### Attributes:


#### Results:

1. `res`: FIR dialect type

### fir.field_index (fir::FieldIndexOp)
create a field index value from a field identifier

#### Description:


Generate a field (offset) value from an identifier.  Field values may be
lowered into exact offsets when the layout of a Fortran derived type is
known at compile-time. The type of a field value is `!fir.field` and
these values can be used with the `fir.coordinate_of`, `fir.extract_value`,
or `fir.insert_value` instructions to compute (abstract) addresses of
subobjects.

```mlir
  %f = fir.field_index field, !fir.type<X{field:i32}>
```

#### Operands:

1. `lenparams`: any integer

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `field_id` | `StringAttr` | string attribute attribute |
| `on_type` | `TypeAttr` | any type attribute attribute |

#### Results:

1. `res`: FIR dialect type

### fir.end (fir::FirEndOp)
the end instruction

#### Description:


The end terminator is a special terminator used inside various FIR
operations that have regions.  End is thus the custom invisible terminator
for these operations.  It is implicit and need not appear in the textual
representation.

#### Operands:


#### Attributes:


#### Results:


### fir.freemem (fir::FreeMemOp)
free a heap object

#### Description:


Deallocates a heap memory reference that was allocated by an `allocmem`.
The memory object that is deallocated is placed in an undefined state
after `fir.freemem`.  Optimizations may treat the loading of an object
in the undefined state as undefined behavior.  This includes aliasing
references, such as the result of an `fir.embox`.

```mlir
  %21 = fir.allocmem !fir.type<ZT(p:i32){field:i32}>
  ...
  fir.freemem %21 : !fir.heap<!fir.type<ZT>>
```

#### Operands:

1. `heapref`: allocatable type

#### Attributes:


#### Results:


### fir.gendims (fir::GenDimsOp)
generate a value of type `!fir.dims`

#### Description:


The arguments are an ordered list of integral type values that is a
multiple of 3 in length.  Each such triple is defined as: the lower
index, the extent, and the stride for that dimension. The dimension
information is given in the same row-to-column order as Fortran. This
abstract dimension value must describe a reified object, so all dimension
information must be specified.  The extent must be nonnegative and the
stride must not be zero.

```mlir
  %d = fir.gendims %l, %u, %s : (index, index, index) -> !fir.dims<1>
```

#### Operands:

1. `triples`: any integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: dim type

### fir.gentypedesc (fir::GenTypeDescOp)
generate a type descriptor for a given type

#### Description:


Generates a constant object that is an abstract type descriptor of the
specified type.  The meta-type of a type descriptor for the type `T`
is `!fir.tdesc<T>`.

```mlir
  !T = type !fir.type<T{...}>
  %t = fir.gentypedesc !T  // returns value of !fir.tdesc<!T>
```

#### Operands:


#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `in_type` | `TypeAttr` | Fortran surface type attribute |

#### Results:

1. `res`: FIR dialect type

### fir.global_len (fir::GlobalLenOp)
map a LEN parameter to a global

#### Description:


A global entity (that is not an automatic data object) can have extra LEN
parameter (compile-time) constants associated with the instance's type.
These values can be bound to the global instance used `fir.global_len`.

```mlir
  global @g : !fir.type<t(len1:i32)> {
    fir.global_len len1, 10 : i32
    %1 = fir.undefined : !fir.type<t(len1:i32)>
    return %1 : !fir.type<t(len1:i32)>
  }
```

#### Operands:


#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `lenparam` | `StringAttr` | string attribute attribute |
| `intval` | `IntegerAttr` | arbitrary integer attribute attribute |

#### Results:


### fir.global (fir::GlobalOp)
Global data

#### Description:


A global variable or constant with initial values.

The example creates a global variable (writable) named
`@_QV_Mquark_Vvarble` with some initial values. The initializer should
conform to the variable's type.

```mlir
  fir.global @_QV_Mquark_Vvarble : tuple<i32, f32> {
    %1 = constant 1 : i32
    %2 = constant 2.0 : f32
    %3 = fir.undefined tuple<i32, f32>
    %z = constant 0 : index
    %o = constant 1 : index
    %4 = fir.insert_value %3, %1, %z : (tuple<i32, f32>, i32, index) -> tuple<i32, f32>
    %5 = fir.insert_value %4, %1, %o : (tuple<i32, f32>, f32, index) -> tuple<i32, f32>
    return %5
  }
```

#### Operands:


#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `sym_name` | `StringAttr` | string attribute attribute |
| `initval` | `Attribute` | any attribute attribute |
| `constant` | `UnitAttr` | unit attribute attribute |
| `type` | `TypeAttr` | any type attribute attribute |

#### Results:

1. `resultType`: reference type

### fir.has_value (fir::HasValueOp)
terminator for GlobalOp

#### Description:


The terminator for a GlobalOp with a body.

```mlir
  global @variable : tuple<i32, f32> {
    %0 = constant 45 : i32
    %1 = constant 100.0 : f32
    %2 = fir.undefined tuple<i32, f32>
    %3 = constant 0 : index
    %4 = fir.insert_value %2, %0, %3 : (tuple<i32, f32>, i32, index) -> tuple<i32, f32>
    %5 = constant 1 : index
    %6 = fir.insert_value %4, %1, %5 : (tuple<i32, f32>, f32, index) -> tuple<i32, f32>
    fir.has_value %6 : tuple<i32, f32>
  }
```

#### Operands:

1. `resval`: any type

#### Attributes:


#### Results:


### fir.insert_value (fir::InsertValueOp)
insert a new sub-value into a copy of an existing aggregate

#### Description:


Insert a value from an entity with a type composed of tuples, arrays,
and/or derived types. Returns a new ssa value with the same type as the
original entity. Cannot be used on values of `!fir.box` type.

Note that the entity ssa-value must be of compile-time known size in order
to use this operation.

```mlir
  %a = ... : !fir.array<10xtuple<i32, f32>>
  %f = ... : f32
  %o = ... : i32
  %c = constant 1 : i32
  %b = fir.insert_value %a, %f, %o, %c : (!fir.array<10x20xtuple<i32, f32>>, f32, i32, i32) -> !fir.array<10x20xtuple<i32, f32>>
```

#### Operands:

1. `adt`: any composite
1. `val`: any type
1. `coor`: coordinate type

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: any composite

### fir.len_param_index (fir::LenParamIndexOp)
create a field index value from a LEN type parameter identifier

#### Description:


Generate a LEN parameter (offset) value from an LEN parameter identifier.
The type of a LEN parameter value is `!fir.len` and these values can be
used with the `fir.coordinate_of` instructions to compute (abstract)
addresses of LEN parameters.

```mlir
  %e = fir.len_param_index len1, !fir.type<X(len1:i32)>
  %p = ... : !fir.box<!fir.type<X>>
  %q = fir.coordinate_of %p, %e : (!fir.box<!fir.type<X>>, !fir.len) -> !fir.ref<i32>
```

#### Operands:


#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `field_id` | `StringAttr` | string attribute attribute |
| `on_type` | `TypeAttr` | any type attribute attribute |

#### Results:

1. `res`: FIR dialect type

### fir.load (fir::LoadOp)
load a value from a memory reference

#### Description:


Load a value from a memory reference into an ssa-value (virtual register).
Produces an immutable ssa-value of the referent type. A memory reference
has type `!fir.ref<T>`, `!fir.heap<T>`, or `!fir.ptr<T>`.

```mlir
  %a = fir.alloca i32
  %l = fir.load %a : !fir.ref<i32>
```

The ssa-value has an undefined value if the memory reference is undefined
or null.

#### Operands:

1. `memref`: any reference

#### Attributes:


#### Results:

1. `res`: FIR dialect type

### fir.loop (fir::LoopOp)
generalized loop operation

#### Description:


Generalized high-level looping construct. This operation is similar to
MLIR's `loop.for`. An ordered loop will return the final value of `%i`.

```mlir
  %l = constant 0 : index
  %u = constant 9 : index
  fir.loop %i = %l to %u unordered {
    %x = fir.convert %i : (index) -> i32
    %v = fir.call @compute(%x) : (i32) -> f32
    %p = fir.coordinate_of %A, %i : (!fir.ref<f32>, index) -> !fir.ref<f32>
    fir.store %v to %p : !fir.ref<f32>
  }
```

The above example iterates over the interval `[%l, %u]`. The unordered
keyword indicates that the iterations can be executed in any order.

#### Operands:

1. `lowerBound`: index
1. `upperBound`: index
1. `optStep`: index

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `constantStep` | `IntegerAttr` | 64-bit integer attribute attribute |
| `unordered` | `UnitAttr` | unit attribute attribute |

#### Results:

1. `lastVal`: index

### fir.modf (fir::ModfOp)


#### Description:



#### Operands:

1. `lhs`: any real
1. `rhs`: any real

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: any type

### fir.mulc (fir::MulcOp)


#### Description:



#### Operands:

1. `lhs`: FIR complex type
1. `rhs`: FIR complex type

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: any type

### fir.mulf (fir::MulfOp)


#### Description:



#### Operands:

1. `lhs`: any real
1. `rhs`: any real

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: any type

### fir.negc (fir::NegcOp)


#### Description:



#### Operands:

1. `operand`: FIR complex type

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: any type

### fir.negf (fir::NegfOp)


#### Description:



#### Operands:

1. `operand`: any real

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: any type

### fir.no_reassoc (fir::NoReassocOp)
synthetic op to prevent reassociation

#### Description:


Primitive operation meant to intrusively prevent operator reassociation.
The operation is otherwise a nop and the value returned is the same as the
argument.

The presence of this operation prevents any local optimizations. In the
example below, this would prevent possibly replacing the multiply and add
operations with a single FMA operation.

```mlir
  %98 = mulf %96, %97 : f32
  %99 = fir.no_reassoc %98 : f32
  %a0 = addf %99, %95 : f32
```

#### Operands:

1. `val`: any type

#### Attributes:


#### Results:

1. `res`: FIR dialect type

### fir.select_case (fir::SelectCaseOp)
Fortran's SELECT CASE statement

#### Description:


Similar to `select`, `select_case` provides a way to express Fortran's
SELECT CASE construct.  In this case, the selector value is matched
against variables (not just constants) and ranges.  The structure is
the same as `select`, but `select_case` allows for the expression of
more complex match conditions.

```mlir
  fir.select_case %arg : i32 [
        #fir.point, %0, ^bb1(%0 : i32),
        #fir.lower, %1, ^bb2(%2,%arg,%arg2,%1 : i32,i32,i32,i32),
        #fir.interval, %2, %3, ^bb3(%2,%arg2 : i32,i32),
        #fir.upper, %arg, ^bb4(%1 : i32),
        unit, ^bb5]
```

#### Operands:

1. `args`: any type

#### Attributes:


#### Results:


### fir.select (fir::SelectOp)
a multiway branch

#### Description:


A multiway branch terminator with similar semantics to C's `switch`
statement.  A selector value is matched against a list of constants
of the same type for a match.  When a match is found, control is
transferred to the corresponding basic block.  A `select` must have
at least one basic block with a corresponding `unit` match, and
that block will be selected when all other conditions fail to match.

```mlir
  fir.select %arg:i32 [1, ^bb1(%0 : i32),
                       2, ^bb2(%2,%arg,%arg2 : i32,i32,i32),
                      -3, ^bb3(%arg2,%2 : i32,i32),
                       4, ^bb4(%1 : i32),
                    unit, ^bb5]
```

#### Operands:

1. `args`: any type

#### Attributes:


#### Results:


### fir.select_rank (fir::SelectRankOp)
Fortran's SELECT RANK statement

#### Description:


Similar to `select`, `select_rank` provides a way to express Fortran's
SELECT RANK construct.  In this case, the rank of the selector value
is matched against constants of integer type.  The structure is the
same as `select`, but `select_rank` determines the rank of the selector
variable at runtime to determine the best match.

```mlir
  fir.select_rank %arg:i32 [1, ^bb1(%0 : i32),
                            2, ^bb2(%2,%arg,%arg2 : i32,i32,i32),
                            3, ^bb3(%arg2,%2 : i32,i32),
                           -1, ^bb4(%1 : i32),
                         unit, ^bb5]
```

#### Operands:

1. `args`: any type

#### Attributes:


#### Results:


### fir.select_type (fir::SelectTypeOp)
Fortran's SELECT TYPE statement

#### Description:


Similar to `select`, `select_type` provides a way to express Fortran's
SELECT TYPE construct.  In this case, the type of the selector value
is matched against a list of type descriptors.  The structure is the
same as `select`, but `select_type` determines the type of the selector
variable at runtime to determine the best match.

```mlir
  fir.select_type %arg : !fir.box<()> [
      #fir.instance<!fir.type<type1>>, ^bb1(%0 : i32),
      #fir.instance<!fir.type<type2>>, ^bb2(%2 : i32),
      #fir.subsumed<!fir.type<type3>>, ^bb3(%2 : i32),
      #fir.instance<!fir.type<type4>>, ^bb4(%1,%3 : i32,f32),
      unit, ^bb5]
```

#### Operands:

1. `args`: any type

#### Attributes:


#### Results:


### fir.store (fir::StoreOp)
store an SSA-value to a memory location

#### Description:


Store an ssa-value (virtual register) to a memory reference.  The stored
value must be of the same type as the referent type of the memory
reference.

```mlir
  %v = ... : f64
  %p = ... : !fir.ptr<f64>
  fir.store %v to %p : !fir.ptr<f64>
```

The above store changes the value to which the pointer is pointing and not
the pointer itself. The operation is undefined if the memory reference,
`%p`, is undefined or null.

#### Operands:

1. `value`: any type
1. `memref`: any reference

#### Attributes:


#### Results:


### fir.string_lit (fir::StringLitOp)
create a string literal constant

#### Description:


An FIR constant that represents a sequence of characters that correspond
to Fortran's CHARACTER type, including a LEN.  We support CHARACTER values
of different KINDs (different constant sizes).

```mlir
  %1 = fir.string_lit "Hello, World!"(13) : !fir.char<1> // ASCII
  %2 = fir.string_lit [158, 2345](2) : !fir.char<2>      // Wide chars
```

#### Operands:


#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: array type

### fir.subc (fir::SubcOp)


#### Description:



#### Operands:

1. `lhs`: FIR complex type
1. `rhs`: FIR complex type

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: any type

### fir.subf (fir::SubfOp)


#### Description:



#### Operands:

1. `lhs`: any real
1. `rhs`: any real

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: any type

### fir.unboxchar (fir::UnboxCharOp)
unbox a boxchar value into a pair value

#### Description:


Unboxes a value of `boxchar` type into a pair consisting of a memory
reference to the CHARACTER data and the LEN type parameter.

```mlir
  %45   = ... : !fir.boxchar<1>
  %46:2 = fir.unboxchar %45 : (!fir.boxchar<1>) -> (!fir.ref<!fir.character<1>>, i32)
```

#### Operands:

1. `boxchar`: box character type

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: reference type
1. &laquo;unnamed&raquo;: any integer

### fir.unbox (fir::UnboxOp)
unbox the boxed value into a tuple value

#### Description:


Unbox a boxed value into a result of multiple values from the box's
component data.  The values are, minimally, a reference to the data of the
entity, the byte-size of one element, the rank, the type descriptor, a set
of flags (packed in an integer, and an array of dimension information (of
size rank).

```mlir
  %40   = ... : !fir.box<!fir.type<T>>
  %41:6 = fir.unbox %40 : (!fir.box<!fir.type<T>>) -> (!fir.ref<!fir.type<T>>, i32, i32, !fir.tdesc<!fir.type<T>>, i32, !fir.dims<4>)
```

#### Operands:

1. `box`: box type

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: reference type
1. &laquo;unnamed&raquo;: any integer
1. &laquo;unnamed&raquo;: any integer
1. &laquo;unnamed&raquo;: type desc type
1. &laquo;unnamed&raquo;: any integer
1. &laquo;unnamed&raquo;: dim type

### fir.unboxproc (fir::UnboxProcOp)
unbox a boxproc value into a pair value

#### Description:


Unboxes a value of `boxproc` type into a pair consisting of a procedure
pointer and a pointer to a host context.

```mlir
  %47   = ... : !fir.boxproc<() -> i32>
  %48:2 = fir.unboxproc %47 : (!fir.ref<() -> i32>, !fir.ref<tuple<f32, i32>>)
```

#### Operands:

1. `boxproc`: box procedure type

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: function type
1. `refTuple`: reference type

### fir.undefined (fir::UndefOp)
explicit undefined value of some type

#### Description:


Constructs an ssa-value of the specified type with an undefined value.
This operation is typically created internally by the mem2reg conversion
pass. An undefined value can be of any type except `!fir.ref<T>`.

```mlir
  %a = fir.undefined !fir.array<10 x !fir.type<T>>
```

The example creates an array shaped ssa value. The array is rank 1, extent
10, and each element has type `!fir.type<T>`.

#### Operands:


#### Attributes:


#### Results:

1. `intype`: any type

### fir.unreachable (fir::UnreachableOp)
the unreachable instruction

#### Description:


Terminates a basic block with the assertion that the end of the block
will never be reached at runtime.  This instruction can be used
immediately after a call to the Fortran runtime to terminate the
program, for example.  This instruction corresponds to the LLVM IR
instruction `unreachable`.

```mlir
  fir.unreachable
```

#### Operands:


#### Attributes:


#### Results:


### fir.where (fir::WhereOp)
generalized conditional operation

#### Description:


To conditionally execute operations (typically) within the body of a
`fir.loop` operation. This operation is similar to `loop.if`.

```mlir
  %56 = ... : i1
  %78 = ... : !fir.ref<!T>
  fir.where %56 {
    fir.store %76 to %78 : !fir.ref<!T>
  } otherwise {
    fir.store %77 to %78 : !fir.ref<!T>
  }
```

#### Operands:

1. `condition`: 1-bit integer

#### Attributes:


#### Results:


